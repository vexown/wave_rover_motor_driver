/*******************************************************************************/
/*                                INCLUDES                                     */
/*******************************************************************************/

/* C Standard Libraries */
#include <stdio.h>
#include <string.h>

/* ESP-IDF includes */
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_event.h"
#include "esp_log.h"
#include "esp_check.h"
#include "esp_wifi_types.h"
#include <lwip/ip_addr.h>

/* Project includes */
#include "wifi_manager.h"
#include "WiFi_Credentials.h" // WiFi credentials (not committed to the repo, you must provide it locally)

/*******************************************************************************/
/*                                 MACROS                                      */
/*******************************************************************************/
#define WIFI_MAXIMUM_RETRY 5

/* Event group bits for WiFi connection status */
#define WIFI_CONNECTED_BIT BIT0 // We have connected to the AP specified in the WiFi credentials
#define WIFI_FAIL_BIT      BIT1 // We have failed to connect to the AP after max retries

static const char *TAG = "wifi_manager";

/*******************************************************************************/
/*                            GLOBAL VARIABLES                                 */
/*******************************************************************************/

/* WiFi event group for connection state management */
EventGroupHandle_t WiFi_EventGroup = NULL;

/* Buffer to store the current IP address in STA mode (e.g., "192.168.1.100") */
char STA_IP_Addr_String[16] = "0.0.0.0";

/*******************************************************************************/
/*                            STATIC VARIABLES                                 */
/*******************************************************************************/

/* Retry counter for WiFi connection attempts */
static int s_retry_num = 0;

/* Callback configuration */
static wifi_manager_callbacks_t s_callbacks = {0};

/*******************************************************************************/
/*                        STATIC FUNCTION DECLARATIONS                         */
/*******************************************************************************/

/**
 * @brief Event handler for WiFi events.
 *
 * @details This function is registered to handle events generated by the WiFi driver,
 * such as station start and disconnection. It manages connection retries and
 * updates the WiFi event group status (WIFI_CONNECTED_BIT, WIFI_FAIL_BIT).
 *
 * @param arg User data pointer passed during registration (not used here).
 * @param event_base The base ID of the event (e.g., WIFI_EVENT).
 * @param event_id The specific ID of the event (e.g., WIFI_EVENT_STA_START).
 * @param event_data Data associated with the event (e.g., disconnection reason).
 * @return void
 */
static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);

/**
 * @brief Event handler for IP stack events.
 *
 * @details This function is registered to handle events from the TCP/IP stack,
 * specifically when the station interface gets an IP address (IP_EVENT_STA_GOT_IP).
 * It updates the WiFi event group, stores the obtained IP address, and updates
 * the OLED display if available.
 *
 * @param arg User data pointer passed during registration (not used here).
 * @param event_base The base ID of the event (e.g., IP_EVENT).
 * @param event_id The specific ID of the event (e.g., IP_EVENT_STA_GOT_IP).
 * @param event_data Data associated with the event (contains IP information).
 * @return void
 */
static void ip_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);

/*******************************************************************************/
/*                        STATIC FUNCTION DEFINITIONS                          */
/*******************************************************************************/

static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    /* Suppress unused parameter warnings */
    (void)arg;
    (void)event_data;

    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) 
    {
        /* Clear connected bit on start attempt */
        if (WiFi_EventGroup != NULL) 
        {
            xEventGroupClearBits(WiFi_EventGroup, WIFI_CONNECTED_BIT);
        }
        /* Connect only after the WIFI_EVENT_STA_START event is received, which indicates
         * that the WiFi driver is ready to connect to an Access Point (AP). */
        esp_wifi_connect();
        ESP_LOGI(TAG, "WIFI_EVENT_STA_START: Connecting...");
    } 
    else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) 
    {
        /* Invoke user disconnect callback if registered */
        if (s_callbacks.on_disconnect) 
        {
            esp_err_t cb_result = s_callbacks.on_disconnect();
            if (cb_result != ESP_OK) 
            {
                ESP_LOGE(TAG, "Disconnect callback failed, restarting system");
                esp_restart();
            }
        }

        /* Clear connected bit on disconnect */
        if (WiFi_EventGroup != NULL) 
        {
            xEventGroupClearBits(WiFi_EventGroup, WIFI_CONNECTED_BIT);
        }
        /* In case of disconnection, attempt to connect again for maximum of WIFI_MAXIMUM_RETRY times */
        if (s_retry_num < WIFI_MAXIMUM_RETRY) 
        {
            esp_wifi_connect();

            s_retry_num++;
            ESP_LOGI(TAG, "Retry connection to the AP (%d/%d)", s_retry_num, WIFI_MAXIMUM_RETRY);
        } 
        else 
        {
            /* After all retires failed, set the event group bit to indicate failure */
            if (WiFi_EventGroup != NULL) 
            {
                xEventGroupSetBits(WiFi_EventGroup, WIFI_FAIL_BIT);
            }
            ESP_LOGE(TAG, "Connect to the AP failed after %d retries", WIFI_MAXIMUM_RETRY);

            /* Invoke status display callback if registered */
            if (s_callbacks.on_status_update) 
            {
                s_callbacks.on_status_update("WiFi Failed!", "");
            }
        }
    } /* add handling of other WiFi event cases if needed */
}

static void ip_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    /* Suppress unused parameter warnings */
    (void)arg;

    if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) 
    {
        /* Cast event_data to the appropriate type */
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;

        /* Log the obtained IP address */
        ESP_LOGI(TAG, "Got IP:" IPSTR, IP2STR(&event->ip_info.ip));

        /* Reset retry counter on successful connection */
        s_retry_num = 0;

        /* Convert IP address to string format and store it in STA_IP_Addr_String */
        snprintf(STA_IP_Addr_String, sizeof(STA_IP_Addr_String), IPSTR, IP2STR(&event->ip_info.ip));

        /* Set the WiFi event group bit to indicate successful connection and clear the fail bit */
        if (WiFi_EventGroup != NULL) 
        {
            xEventGroupClearBits(WiFi_EventGroup, WIFI_FAIL_BIT); // Clear potential previous failure
            xEventGroupSetBits(WiFi_EventGroup, WIFI_CONNECTED_BIT);
        }
        
        /* Invoke status display callback if registered */
        if (s_callbacks.on_status_update) 
        {
            char detail_buf[20];
            snprintf(detail_buf, sizeof(detail_buf), "IP:%s", STA_IP_Addr_String);
            s_callbacks.on_status_update("WiFi Connected", detail_buf);
        }
    } /* add handling of other IP event cases if needed */
}

/*******************************************************************************/
/*                        GLOBAL FUNCTION DEFINITIONS                          */
/*******************************************************************************/

esp_err_t wifi_manager_init(const wifi_manager_callbacks_t *callbacks)
{
    ESP_LOGI(TAG, "Initializing WiFi...");

    /* Store callbacks if provided */
    if (callbacks != NULL) 
    {
        memcpy(&s_callbacks, callbacks, sizeof(wifi_manager_callbacks_t));
    } 
    else 
    {
        memset(&s_callbacks, 0, sizeof(wifi_manager_callbacks_t));
    }

    /* Initialize the WiFi event group which will be used to signal connection status */
    WiFi_EventGroup = xEventGroupCreate();
    if (WiFi_EventGroup == NULL) 
    {
        ESP_LOGE(TAG, "Failed to create WiFi event group");
        return ESP_FAIL;
    }

    /* Get the default WiFi initialization config and use it to initialize the WiFi driver */
    /* The esp_wifi_init() function initializes the WiFi driver with the provided configuration.
     * The default configuration is used here, which is suitable for most applications.
     * It can be customized if needed by modifying the wifi_init_config_t structure.
     **/  
    wifi_init_config_t wifi_cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_err_t wifi_init_err = esp_wifi_init(&wifi_cfg);
    if (wifi_init_err != ESP_OK)
    {
        ESP_LOGE(TAG, "WiFi init failed: %s", esp_err_to_name(wifi_init_err));
        return wifi_init_err;
    }

    /* #01 - Register the event handlers for WiFi and IP events */
    /* The event handlers are registered to handle specific events related to WiFi and IP.
     * The wifi_event_handler() function handles WiFi events (e.g., connection, disconnection),
     * while the ip_event_handler() function handles IP events (e.g., obtaining an IP address).
     * The event handlers are registered with the default event loop created earlier.
     **/
    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_RETURN_ON_ERROR(esp_event_handler_instance_register(WIFI_EVENT,
                                                            ESP_EVENT_ANY_ID,    // Any event related to WiFi
                                                            &wifi_event_handler, // Function to handle the registered event
                                                            NULL,                // No argument passed to the handler
                                                            &instance_any_id), TAG, "Register WIFI_EVENT failed");
    ESP_RETURN_ON_ERROR(esp_event_handler_instance_register(IP_EVENT,
                                                            IP_EVENT_STA_GOT_IP, // Event when the station gets an IP address
                                                            &ip_event_handler,   // Function to handle the registered event
                                                            NULL,                // No argument passed to the handler
                                                            &instance_got_ip), TAG, "Register IP_EVENT failed");

    /* #02 - Define the WiFi STA mode configuration */
    /* This config is different from the wifi_init_config_t used before, which is for the driver initialization. 
     * This one is specifically for configuring the parameters of either STA or AP mode (STA+AP mode is also possible).
     **/
    wifi_config_t wifi_config = 
    {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASSWORD,
            /* Authmode threshold defaults to WPA2 PSK. */
            .threshold.authmode = WIFI_AUTH_WPA2_PSK, // Or adjust as needed (WIFI_AUTH_WPA_WPA2_PSK, etc.)
            .sae_pwe_h2e = WPA3_SAE_PWE_BOTH, // Enable WPA3 support if needed
        },
    };

    esp_err_t wifi_mode_err = esp_wifi_set_mode(WIFI_MODE_STA);
    if (wifi_mode_err != ESP_OK)
    {
        ESP_LOGE(TAG, "WiFi set mode failed: %s", esp_err_to_name(wifi_mode_err));
        return wifi_mode_err;
    }

    /* #03 - Configure and connect (WiFi driver already initialized) */
    ESP_RETURN_ON_ERROR(esp_wifi_set_config(WIFI_IF_STA, &wifi_config), TAG, "esp_wifi_set_config failed");

    ESP_RETURN_ON_ERROR(esp_wifi_start(), TAG, "esp_wifi_start failed");

    /* #08 - Connection should now be triggered by the wifi_event_handler via esp_wifi_connect() once the WIFI_EVENT_STA_START
     * event is received. The connection process will be handled in the event handler.
     * The handler will also set the bits in the WiFi_EventGroup to indicate success or failure.
     **/
    ESP_LOGI(TAG, "WiFi initialized in STA mode, attempting to connect to SSID: %s", WIFI_SSID);

    /* #04 - Wait for the connection to complete or fail */
    /* The xEventGroupWaitBits() function blocks the calling task until one of the specified bits is set in the event group.
     * In this case, it waits for either the WIFI_CONNECTED_BIT or WIFI_FAIL_BIT to be set.
     * The pdFALSE flag indicates that the bits should not be cleared on exit, and portMAX_DELAY means wait indefinitely.
     **/
    EventBits_t bits = xEventGroupWaitBits(WiFi_EventGroup,
                                            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
                                            pdFALSE,        // Don't clear bits on exit
                                            pdFALSE,        // Wait for EITHER bit
                                            portMAX_DELAY); // Wait indefinitely

    if (bits & WIFI_CONNECTED_BIT) 
    {
        ESP_LOGI(TAG, "Connected to AP SSID:%s", WIFI_SSID);
        
        /* Get and print the WiFi channel */
        uint8_t primary_channel = 0;
        wifi_second_chan_t secondary_channel = WIFI_SECOND_CHAN_NONE;
        esp_err_t channel_err = wifi_manager_get_channel(&primary_channel, &secondary_channel);
        
        if (channel_err == ESP_OK) 
        {
            ESP_LOGI(TAG, "WiFi Channel: %d", primary_channel);
            
            if (secondary_channel != WIFI_SECOND_CHAN_NONE) 
            {
                ESP_LOGI(TAG, "Secondary Channel: %d (HT40 mode)", secondary_channel);
            }
        }
        
        return ESP_OK;
    } 
    else if (bits & WIFI_FAIL_BIT) 
    {
        ESP_LOGE(TAG, "Failed to connect to SSID:%s", WIFI_SSID);
        return ESP_FAIL;
    } 
    else 
    {
        ESP_LOGE(TAG, "UNEXPECTED EVENT");
        return ESP_FAIL;
    }
}

esp_err_t wifi_manager_deinit(void)
{
    if (WiFi_EventGroup != NULL)
    {
        vEventGroupDelete(WiFi_EventGroup);
        WiFi_EventGroup = NULL;
    }
    return esp_wifi_stop();
}

esp_err_t wifi_manager_get_channel(uint8_t *primary_channel, wifi_second_chan_t *secondary_channel)
{
    /* Get the current WiFi channel from the driver */
    /* This function can only be called after WiFi has been initialized and connected */
    
    if (primary_channel == NULL || secondary_channel == NULL)
    {
        ESP_LOGE(TAG, "Invalid parameters passed to wifi_manager_get_channel()");
        return ESP_ERR_INVALID_ARG;
    }
    
    /* Initialize pointers */
    *secondary_channel = WIFI_SECOND_CHAN_NONE;
    
    /* Retrieve current channel from WiFi driver */
    /* This works both in STA and AP mode */
    esp_err_t ret = esp_wifi_get_channel(primary_channel, secondary_channel);
    
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "Failed to get WiFi channel: 0x%x", ret);
        return ret;
    }
    
    return ESP_OK;
}
